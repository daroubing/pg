#!/usr/bin/env python
#! -*- coding: utf-8 -*-

import re
import os
import sys
import tempfile
import optparse
import ConfigParser
import subprocess
import shutil


def keep_path(func):
    def wrapper(*args, **kwargs):
        cwd = os.getcwd()
        res = func(*args, **kwargs)
        os.chdir(cwd)
        return res
    return wrapper


class PG(object):
    IMPORT_PATTERN = re.compile('^\s*import')
    PROTOFILE = "protocol"

    def __init__(self, configfile, protofiles):
        proto_dir = os.path.dirname(os.path.realpath(protofiles[0]))
        self.define_ini = os.path.join(proto_dir, 'define.ini')
        if not os.path.exists(self.define_ini):
            raise OSError("No 'define.ini' Found in proto dirs")

        _define_ini = ConfigParser.ConfigParser()
        _define_ini.optionxform = str
        _define_ini.read(self.define_ini)
        self.define_items = _define_ini.items('define')

        self.protofiles = protofiles
        self.cf = ConfigParser.ConfigParser()
        self.cf.read(configfile)
        self.build_param()
        self.make_temp_files()
        print "Start..."
        print "TmpDir {0}".format(self.tmp_dir)
        print "OutDir {0}".format(self.config_outdir)

        self.merge_proto_to_one_file()


    def make_temp_files(self):
        self.tmp_dir = tempfile.mkdtemp()
        self.tmp_proto_file = os.path.join(self.tmp_dir, self.PROTOFILE)


    def exit(self, exit_code=0):
        # shutil.rmtree(self.tmp_dir)
        sys.exit(exit_code)


    def build_param(self):
        outdir = self.cf.get('global', 'outdir')
        if outdir.startswith('/'):
            # absolute path
            self.config_outdir = outdir
        else:
            self.config_outdir = os.path.join(os.getcwd(), outdir)

        self.config_protoc = self.cf.get('global', 'protoc')


    def merge_proto_to_one_file(self):
        print "Merge Protobufs to One File..."
        with open(self.tmp_proto_file, 'a') as tmpf:
            for p in self.protofiles:
                for line in file(p):
                    if self.IMPORT_PATTERN.search(line) is not None:
                        # ignore the `import ...` line
                        continue

                    tmpf.write(line)


    def run_subprocess(self, cmd):
        # print "Run: {0}".format(' '.join(cmd))
        pipe = subprocess.PIPE
        p = subprocess.Popen(cmd, stdout=pipe, stderr=pipe)
        exitcode = p.wait()
        stdout, stderr = p.communicate()
        if exitcode:
            # error
            print "CMD ERROR:", ' '.join(cmd)
            print stderr
            self.exit(1)

        return stdout

    @keep_path
    def generate_description(self):
        print "Generate Protobuf Description..."
        os.chdir(self.tmp_dir)

        name = "{0}.protobin".format(os.path.basename(self.tmp_proto_file))
        cmd = [self.config_protoc,
               "--descriptor_set_out={0}".format(name),
               os.path.basename(self.tmp_proto_file)
               ]
        self.run_subprocess(cmd)
        return name


    @keep_path
    def process_csharp(self):
        print
        print "Process Charp..."

        config_mono = self.cf.get('csharp', 'mono')
        config_gmcs = self.cf.get('csharp', 'gmcs')
        config_protogen = self.cf.get('csharp', 'protogen')
        config_pro_out = self.cf.get('csharp', 'protogen_out')
        config_pro_namespace = self.cf.get('csharp', 'protogen_namespace')

        config_precompile = self.cf.get('csharp', 'precompile')
        config_pre_out = self.cf.get('csharp', 'precompile_out')
        config_pre_namespace = self.cf.get('csharp', 'precompile_namespace')

        config_protobufdll = self.cf.get('csharp', 'protobufdll')

        cs_file = "{0}.cs".format(os.path.basename(self.tmp_proto_file))
        os.chdir(self.tmp_dir)
        def generate_protocol_csharp():
            print "Generate Csharp File..."
            des_file = self.generate_description()

            cmd = [config_mono,
                   config_protogen,
                   "-i:{0}".format(des_file),
                   "-o:{0}".format(cs_file),
                   "-ns:{0}".format(config_pro_namespace)
                   ]

            self.run_subprocess(cmd)

        def generate_protocol_dll():
            print "Generate Protocol DLL..."
            shutil.copy(config_protobufdll, self.tmp_dir)
            cmd = [config_gmcs,
                   "-t:library",
                   "-r:{0}".format(config_protobufdll),
                   "-out:{0}".format(config_pro_out),
                   cs_file
                   ]

            self.run_subprocess(cmd)

        def generate_precompile_dll():
            print "Generate Precompiled DLL..."
            cmd = [config_mono,
                   config_precompile,
                   config_pro_out,
                   "-o:{0}".format(config_pre_out),
                   "-t:{0}".format(config_pre_namespace)
                  ]

            self.run_subprocess(cmd)

        def generate_protocol_handler_file():
            print "Generate Protocol Handler File..."
            os.makedirs(os.path.join('Protocol', 'Handler'))
            file_name = os.path.join('Protocol', 'Handler', 'Handler.cs')
            template = """
using System;
using System.IO;
using System.Net;
using System.Collections.Generic;

namespace MyProject.Protocol
{


    public static class ProtocolHandler
    {
        private readonly static Dictionary<int, Type> IdToTypeDict = new Dictionary<int, Type>{
%s
        };

        private readonly static Dictionary<Type, int> TypeToIdDict = new Dictionary<Type, int>{
%s
        };

        private readonly static Dictionary<Type, Action<Object>> MethodDispatcher = new Dictionary<Type,  Action<Object>>{
%s
        };

        public static Type GetProtocolTypeById(int id)
        {
            return IdToTypeDict[id];
        }


        public static byte[] Pack(Object data)
        {
            using (var ms = new MemoryStream())
            {
                var ser = new MyProject.Protocol.ProtocolSerializer();
                ser.Serialize(ms, data);
                return ms.ToArray();
            }
        }

%s

        public static void UnPack(byte[] data)
        {
            var ms = new MemoryStream(data);
            var br = new BinaryReader(ms);

            var id = br.ReadInt32();
            id = IPAddress.NetworkToHostOrder(id);

            var dataBytes = br.ReadBytes(data.Length - 4);
            ms.Close();

            var dataStream = new MemoryStream(dataBytes);

            var ser = new MyProject.Protocol.ProtocolSerializer();
            var protocolType = GetProtocolTypeById(id);
            var msg = ser.Deserialize(dataStream, null, protocolType);

            dataStream.Close();

            MethodDispatcher[protocolType](msg);
        }
    }
}
"""

            pack_with_id_template = """
        public static byte[] PackWithId(MyProject.Protocol.Define.%s data)
        {
            var id = %s;
            var dataBytes = Pack(data);

            id = IPAddress.HostToNetworkOrder(id);
            var idBytes = BitConverter.GetBytes(id);

            byte[] buffer = new byte[dataBytes.Length + idBytes.Length];

            idBytes.CopyTo(buffer, 0);
            dataBytes.CopyTo(buffer, idBytes.Length);
            return buffer;
        }
            """


            id_type_dict = []
            for name, _id in self.define_items:
                line = "            {%s, typeof(MyProject.Protocol.Define.%s)}," % (_id, name)
                id_type_dict.append(line)

            type_id_dict = []
            for name, _id in self.define_items:
                line = "            {typeof(MyProject.Protocol.Define.%s), %s}," % (name, _id)
                type_id_dict.append(line)

            method_dispatcher = []
            for name, _id in self.define_items:
                line = "            {typeof(MyProject.Protocol.Define.%s), (Object o) => MyProject.Protocol.Implement.%s.Process((MyProject.Protocol.Define.%s)o)}," % (
                    name, name, name
                )
                method_dispatcher.append(line)

            pack_with_id = []
            for name, _id in self.define_items:
                code_area = pack_with_id_template % (name, _id)
                pack_with_id.append(code_area)


            with open(file_name, 'w') as f:
                file_content = template % (
                    '\n'.join(id_type_dict),
                    '\n'.join(type_id_dict),
                    '\n'.join(method_dispatcher),
                    '\n'.join(pack_with_id)
                )

                f.write(file_content)


        def generate_protocol_implement_files():

            print "Generate Protocol Implement Files..."
            os.makedirs(os.path.join('Protocol', 'Implement'))
            template = """
using System;

namespace MyProject.Protocol.Implement
{
    public static class %s
    {
        public static void Process(%s msg)
        {
            // Logic here
        }
    }
}
"""
            for name, _ in self.define_items:
                file_name = os.path.join('Protocol', 'Implement', name + '.cs')
                file_content = template % (name, 'MyProject.Protocol.Define.' + name)
                with open(file_name, 'w') as f:
                    f.write(file_content)


        generate_protocol_csharp()
        generate_protocol_dll()
        generate_precompile_dll()
        generate_protocol_handler_file()
        generate_protocol_implement_files()

        return [config_pro_out, config_pre_out, os.path.basename(config_protobufdll)]


    @keep_path
    def process_erlang(self):
        print
        print "Process Erlang..."

        os.chdir(self.tmp_dir)

        config_protoc_erl = self.cf.get('erlang', 'protoc-erl')
        config_gpb_hrl = self.cf.get('erlang', 'gpb_hrl')
        config_msgprefix = self.cf.get('erlang', 'msgprefix')
        config_msgsuffix = self.cf.get('erlang', 'msgsuffix')
        config_filename = self.cf.get('erlang', 'filename')

        proto_name = "{0}.proto".format(config_filename)
        shutil.copy(os.path.basename(self.tmp_proto_file), proto_name)
        shutil.copy(config_gpb_hrl, self.tmp_dir)

        cmd = [config_protoc_erl,
               "-o", ".",
               "-I", ".",
               "-strbin",
               proto_name
              ]

        if config_msgprefix:
            cmd.append("-msgprefix")
            cmd.append(config_msgprefix)

        if config_msgsuffix:
            cmd.append("-msgsuffix")
            cmd.append(config_msgsuffix)


        self.run_subprocess(cmd)

        return ["{0}.erl".format(config_filename),
                "{0}.hrl".format(config_filename),
                os.path.basename(config_gpb_hrl),
                ]


    @keep_path
    def process_python(self):
        return []
        # print
        # print "Process Python"
        #
        # os.chdir(self.tmp_dir)
        #
        # config_filename = self.cf.get('python', 'filename')
        #
        # cmd = [self.config_protoc,
        #        "--python_out=.",
        #        os.path.basename(self.tmp_proto_file)
        #       ]
        #
        # self.run_subprocess(cmd)
        #
        # pb2 = "{0}_pb2.py".format(os.path.basename(self.tmp_proto_file))
        # shutil.copy(pb2, config_filename)
        #
        # return [config_filename]


    def copy_to_outdir(self, section, files):
        folder = os.path.join(self.config_outdir, section)
        if not os.path.isdir(folder):
            os.makedirs(folder, 0755)
        for f in files:
            f_path = os.path.join(self.tmp_dir, f)
            shutil.copy(f_path, folder)


    def run(self):
        for section in self.cf.sections():
            if section == 'global':
                continue

            method_name = 'process_{0}'.format(section)
            method = getattr(self, method_name)
            files = method()

            self.copy_to_outdir(section, files)

        self.exit()



class ProtocolIdDefine(object):
    # generate a protocol handler file for help pack/unpack message with protocol id
    def __init__(self, configfile):
        cf = ConfigParser.ConfigParser()
        cf.read(configfile)
        self.items = cf.items('define')

    def process(self):
        raise NotImplementedError()


class ProtocolIdDefineErlang(ProtocolIdDefine):
    def process(self):
        template = """
-module(protocol_handler).

-export([decode/2,
         encode/1,
         get_msg_name_by_id/1,
         get_id_by_msg_name/1]).


decode(Msg) ->
    protocol:decode(Msg)

"""






if __name__ == '__main__':
    parse = optparse.OptionParser()
    parse.add_option(
            "-c",
            dest="configfile",
            help="config file to use"
            )

    options, args = parse.parse_args()
    if not options.configfile:
        parse.print_help()
        sys.exit(1)

    if not args:
        print "No input protobuf files"
        sys.exit(1)

    pg = PG(options.configfile, args)
    pg.run()

